#include <stdio.h>

//https://blog.csdn.net/yzy1103203312/article/details/80808117

/*******************************************************************************
 *                                内存分配规则
 *******************************************************************************
 * 原则一：
 *         结构体中元素是按照定义顺序一个一个放到内存中去的，但并不是紧密排列的。
 *         从结构体存储的首地址开始，每一个元素放置到内存中时，它都会认为内存是
 *         以它自己的大小来划分的，因此元素放置的位置一定会在自己宽度的整数倍上
 *         开始（以结构体变量首地址为0计算）。
 * 原则二：
 *         在经过第一原则分析后，检查计算出的存储单元是否为所有元素中最宽的元素
 *         的长度的整数倍，是，则结束；若不是，则补齐为它的整数倍。
 ******************************************************************************
 * 为什么对齐：1.平台原因 2.硬件原因(内存对齐之后，CPU的内存访问速度大大提升)
 *******************************************************************************/

/**
 * 0x0001 0x0002 0x0003 0x0004   0x0005 0x0006 0x0007 0x0008   0x0009 0x0010 0x0011 0x0012
 * ------------a--------------
 * 0x0001 0x0002 0x0003 0x0004 | 0x0005 0x0006 0x0007 0x0008   0x0009 0x0010 0x0011 0x0012
 * ------------a-------------- | ------------c--------------
 * 0x0001 0x0002 0x0003 0x0004 | 0x0005 0x0006 0x0007 0x0008 | 0x0009 0x0010 0x0011 0x0012
 * ------------a-------------- | ------------c-------------- | ------------c--------------
 */
struct yt_t1 {
    int a; //4个字节
    int b; //4个字节
    int c; //4个字节
};

/**
 * 0x0001 | 0x0002 0x0003 0x0004   0x0005 0x0006 0x0007 0x0008   0x0009 0x0010 0x0011 0x0012 0x0013 0x0014 0x0015 0x0016
 * --a--
 * 0x0001 | 0x0002 0x0003 0x0004 | 0x0005 0x0006 0x0007 0x0008   0x0009 0x0010 0x0011 0x0012 0x0013 0x0014 0x0015 0x0016
 * --a--  |                        --------------b------------
 * 0x0001 | 0x0002 0x0003 0x0004 | 0x0005 0x0006 0x0007 0x0008 | 0x0009 0x0010 0x0011 0x0012 0x0013 0x0014 0x0015 0x0016
 * --a--  |                      | --------------b------------ | ---------------------------c---------------------------
 */
struct yt_t2 {

    char   a; //1个字节
    int    b; //4个字节
    double c; //8个字节
};

/**
 * 0x0001 | 0x0002 0x0003 0x0004   0x0005 0x0006 0x0007 0x0008   0x0009 0x0010 0x0011 0x0012 0x0013 0x0014 0x0015 0x0016
 * --a--
 * 0x0001 | 0x0002 0x0003 0x0004 | 0x0005 0x0006 0x0007 0x0008   0x0009 0x0010 0x0011 0x0012 0x0013 0x0014 0x0015 0x0016
 * --a--  |                                                      ---------------------------b---------------------------
 * 0x0001 | 0x0002 0x0003 0x0004 | 0x0005 0x0006 0x0007 0x0008 | 0x0009 0x0010 0x0011 0x0012 0x0013 0x0014 0x0015 0x0016 | 0x0017 0x0018 0x0019 0x0020  0x0021 0x0022 0x0023 0x0024
 * --a--  |                                                    | ---------------------------b--------------------------- | -------------c-------------
 */
struct yt_t3 {

    char   a; //1个字节
    double b; //8个字节
    int    c; //4个字节
};

/**
 * 0x0001 | 0x0002 0x0003 0x0004   0x0005 0x0006 0x0007 0x0008   0x0009 0x0010 0x0011 0x0012
 * --a--
 * 0x0001 | 0x0002 0x0003 0x0004 | 0x0005 0x0006 0x0007 0x0008   0x0009 0x0010 0x0011 0x0012
 * --a--  |                        --------------b------------
 * 0x0001 | 0x0002 0x0003 0x0004 | 0x0005 0x0006 0x0007 0x0008 | 0x0009 0x0010 0x0011 0x0012
 * --a--  |                      | --------------b------------ | -------------c-------------
 */
struct yt_t4 {

    //-------------------------------------------------//
    char a; //1个字节
    int  b; //4个字节
    char c[2]; //2个字节
};


void main ()
{

    typedef struct yt_t3 yt_t;
    yt_t t;

    printf("t sizeof is: %d, addr:%p \n",   sizeof(t), &t);
    printf("-------------------------------\n");

    printf("t.a sizeof is: %d, addr:%p \n", sizeof(t.a), &t.a);
    printf("t.b sizeof is: %d, addr:%p \n", sizeof(t.b), &t.b);
    printf("t.c sizeof is: %d, addr:%p \n", sizeof(t.c), &t.c);
    //printf("t.d sizeof is: %d\n", sizeof(t.d));
}
